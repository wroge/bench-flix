// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"
	"time"
)

const addMovieActor = `-- name: AddMovieActor :exec
INSERT OR IGNORE INTO movie_actors (movie_id, person_id)
VALUES (?, ?)
`

type AddMovieActorParams struct {
	MovieID  int64
	PersonID int64
}

func (q *Queries) AddMovieActor(ctx context.Context, arg AddMovieActorParams) error {
	_, err := q.db.ExecContext(ctx, addMovieActor, arg.MovieID, arg.PersonID)
	return err
}

const addMovieCountry = `-- name: AddMovieCountry :exec
INSERT OR IGNORE INTO movie_countries (movie_id, country_id)
VALUES (?, ?)
`

type AddMovieCountryParams struct {
	MovieID   int64
	CountryID int64
}

func (q *Queries) AddMovieCountry(ctx context.Context, arg AddMovieCountryParams) error {
	_, err := q.db.ExecContext(ctx, addMovieCountry, arg.MovieID, arg.CountryID)
	return err
}

const addMovieDirector = `-- name: AddMovieDirector :exec
INSERT OR IGNORE INTO movie_directors (movie_id, person_id)
VALUES (?, ?)
`

type AddMovieDirectorParams struct {
	MovieID  int64
	PersonID int64
}

func (q *Queries) AddMovieDirector(ctx context.Context, arg AddMovieDirectorParams) error {
	_, err := q.db.ExecContext(ctx, addMovieDirector, arg.MovieID, arg.PersonID)
	return err
}

const addMovieGenre = `-- name: AddMovieGenre :exec
INSERT OR IGNORE INTO movie_genres (movie_id, genre_id)
VALUES (?, ?)
`

type AddMovieGenreParams struct {
	MovieID int64
	GenreID int64
}

func (q *Queries) AddMovieGenre(ctx context.Context, arg AddMovieGenreParams) error {
	_, err := q.db.ExecContext(ctx, addMovieGenre, arg.MovieID, arg.GenreID)
	return err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO movies (id, title, added_at, rating)
VALUES (?, ?, ?, ?)
RETURNING id
`

type CreateMovieParams struct {
	ID      int64
	Title   string
	AddedAt time.Time
	Rating  float64
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createMovie,
		arg.ID,
		arg.Title,
		arg.AddedAt,
		arg.Rating,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE FROM movies WHERE id = ?
`

func (q *Queries) DeleteMovie(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovie, id)
	return err
}

const getMovie = `-- name: GetMovie :one
SELECT
    movies.id,
    movies.title,
    movies.added_at,
    movies.rating,
    CAST(IFNULL((
        SELECT GROUP_CONCAT(name)
        FROM (
            SELECT people.name
            FROM movie_directors
            JOIN people ON people.id = movie_directors.person_id
            WHERE movie_directors.movie_id = movies.id
            ORDER BY people.name ASC
        )
    ), '') AS TEXT) AS directors,
    CAST(IFNULL((
        SELECT GROUP_CONCAT(name)
        FROM (
            SELECT people.name
            FROM movie_actors
            JOIN people ON people.id = movie_actors.person_id
            WHERE movie_actors.movie_id = movies.id
            ORDER BY people.name ASC
        )
    ), '') AS TEXT) AS actors,
    CAST(IFNULL((
        SELECT GROUP_CONCAT(name)
        FROM (
            SELECT countries.name
            FROM movie_countries
            JOIN countries ON countries.id = movie_countries.country_id
            WHERE movie_countries.movie_id = movies.id
            ORDER BY countries.name ASC
        )
    ), '') AS TEXT) AS countries,
    CAST(IFNULL((
        SELECT GROUP_CONCAT(name)
        FROM (
            SELECT genres.name
            FROM movie_genres
            JOIN genres ON genres.id = movie_genres.genre_id
            WHERE movie_genres.movie_id = movies.id
            ORDER BY genres.name
        )
    ), '') AS TEXT) AS genres
FROM movies
WHERE movies.id = ?
`

type GetMovieRow struct {
	ID        int64
	Title     string
	AddedAt   time.Time
	Rating    float64
	Directors string
	Actors    string
	Countries string
	Genres    string
}

func (q *Queries) GetMovie(ctx context.Context, id int64) (GetMovieRow, error) {
	row := q.db.QueryRowContext(ctx, getMovie, id)
	var i GetMovieRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AddedAt,
		&i.Rating,
		&i.Directors,
		&i.Actors,
		&i.Countries,
		&i.Genres,
	)
	return i, err
}

const getOrCreateCountry = `-- name: GetOrCreateCountry :one
INSERT INTO countries (name)
VALUES (?)
ON CONFLICT(name) DO UPDATE SET name = excluded.name
RETURNING id
`

func (q *Queries) GetOrCreateCountry(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateCountry, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getOrCreateGenre = `-- name: GetOrCreateGenre :one
INSERT INTO genres (name)
VALUES (?)
ON CONFLICT(name) DO UPDATE SET name = excluded.name
RETURNING id
`

func (q *Queries) GetOrCreateGenre(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateGenre, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getOrCreatePerson = `-- name: GetOrCreatePerson :one
INSERT INTO people (name)
VALUES (?)
ON CONFLICT(name) DO UPDATE SET name = excluded.name
RETURNING id
`

func (q *Queries) GetOrCreatePerson(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getOrCreatePerson, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const queryMovies = `-- name: QueryMovies :many
SELECT
    movies.id,
    movies.title,
    movies.added_at,
    movies.rating,
    CAST(IFNULL((
        SELECT GROUP_CONCAT(name)
        FROM (
            SELECT people.name
            FROM movie_directors
            JOIN people ON people.id = movie_directors.person_id
            WHERE movie_directors.movie_id = movies.id
            ORDER BY people.name ASC
        )
    ), '') AS TEXT) AS directors,
    CAST(IFNULL((
        SELECT GROUP_CONCAT(name)
        FROM (
            SELECT people.name
            FROM movie_actors
            JOIN people ON people.id = movie_actors.person_id
            WHERE movie_actors.movie_id = movies.id
            ORDER BY people.name ASC
        )
    ), '') AS TEXT) AS actors,
    CAST(IFNULL((
        SELECT GROUP_CONCAT(name)
        FROM (
            SELECT countries.name
            FROM movie_countries
            JOIN countries ON countries.id = movie_countries.country_id
            WHERE movie_countries.movie_id = movies.id
            ORDER BY countries.name ASC
        )
    ), '') AS TEXT) AS countries,
    CAST(IFNULL((
        SELECT GROUP_CONCAT(name)
        FROM (
            SELECT genres.name
            FROM movie_genres
            JOIN genres ON genres.id = movie_genres.genre_id
            WHERE movie_genres.movie_id = movies.id
            ORDER BY genres.name
        )
    ), '') AS TEXT) AS genres
FROM movies
WHERE
    (?1 = '' OR EXISTS (
        SELECT 1
        FROM movie_directors
        JOIN people ON people.id = movie_directors.person_id
        WHERE movie_directors.movie_id = movies.id
        AND INSTR(LOWER(people.name), LOWER(?1)) > 0
    )
    OR EXISTS (
        SELECT 1
        FROM movie_actors
        JOIN people ON people.id = movie_actors.person_id
        WHERE movie_actors.movie_id = movies.id
        AND INSTR(LOWER(people.name), LOWER(?1)) > 0
    ))
    AND (?2 = '' OR EXISTS (
        SELECT 1
        FROM movie_genres
        JOIN genres ON genres.id = movie_genres.genre_id
        WHERE movie_genres.movie_id = movies.id
        AND genres.name = ?2
    ))
    AND (?3 = '' OR EXISTS (
        SELECT 1
        FROM movie_countries
        JOIN countries ON countries.id = movie_countries.country_id
        WHERE movie_countries.movie_id = movies.id
        AND countries.name = ?3
    ))
    AND (?4 IS NULL OR movies.added_at >= ?4)
    AND (?5 IS NULL OR movies.added_at <= ?5)
    AND (?6 <= 0 OR movies.rating >= ?6)
    AND (?7 <= 0 OR movies.rating <= ?7)
ORDER BY movies.title ASC
`

type QueryMoviesParams struct {
	Search      interface{}
	Genre       interface{}
	Country     interface{}
	AddedAfter  interface{}
	AddedBefore interface{}
	MinRating   interface{}
	MaxRating   interface{}
}

type QueryMoviesRow struct {
	ID        int64
	Title     string
	AddedAt   time.Time
	Rating    float64
	Directors string
	Actors    string
	Countries string
	Genres    string
}

func (q *Queries) QueryMovies(ctx context.Context, arg QueryMoviesParams) ([]QueryMoviesRow, error) {
	rows, err := q.db.QueryContext(ctx, queryMovies,
		arg.Search,
		arg.Genre,
		arg.Country,
		arg.AddedAfter,
		arg.AddedBefore,
		arg.MinRating,
		arg.MaxRating,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryMoviesRow
	for rows.Next() {
		var i QueryMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AddedAt,
			&i.Rating,
			&i.Directors,
			&i.Actors,
			&i.Countries,
			&i.Genres,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
